#Subbing in for Brendan
#pretty new to Ruby, so bear with me
#last meeting, talked about basic data types, made a guessing game and a web scraper

#today, going into more collection stuff and getting started with loops


i=0
while i<10 do
  i+=1
  puts i
end

x = gets.to_i
while x<10 do
    puts "#{x} isn't bigger than 10, stupid!"
    x=gets.to_i
end

#ruby above all else trys to be readable, so it follows natural language as much as possible

x=0
until x>10 do
    puts "give me a number bigger than 10"
    x=gets.to_i
end
puts x

x=0
x=gets.to_i until x>10

x=0

if x>10
    puts "cool"
else
    puts "no good!"
end

unless x>10
    puts "no good!"
else
    puts "cool"
end

puts "can't login!" unless password == correct_password

#make sure guessing game is right!
#update guessing game, while loop forever until you guess right
#first way, add a guess _right variable, while !guess_right, loop
#second way, while true, break

####################################################################

#remember arrays
x=[1,3,2,6,5,4]
x.last
x.length
x.sort

for i in x do
    puts i
end
#what if we wanted to do a lot more than 5?
for i in 1..100 do
    puts i
end
for i in 5.upto(10) do
    puts i**2
end

#range
(1..5)  #inclusive
(1...5) #exclusive

#Array vs Range vs Enumerator
[1,2,3].class
(1..5).class
5.upto(10).class
(1..5).to_a

#Anything that returns one of these types will work to, e.g. splits function
for i in "Julian".split("") do p i end
for i in "Georgia Institute of Technology".split(" ") do p i end

#there is also this interesting character, which leads us into the next topic
42.times do p "meow" end
42.times.class

############

#THE RUBY WAY -> blocks / Iterators
[7,12,3].each do |x|
    puts x
end
#do to end is called block -> curly brace shorthand
[7,12,3].each {|x| p x}
(1..5).each {|x| p x}
0.upto(5) {|x| p x}
5.times {|x| p x}


x=(1..100)
x.include?(75)
x.include?(750)
x.reject {|s| s<75}

#Caesar cipher TODO DOESNT WORK
#def caesar(secret, shift)
#    cipher = ""
#    secret.split("").each {|letter| cypher += ((letter.ord + shift - 64) % 64).chr }
#    return cipher
#end

#def decode(cipher, shift)
#    return caesar(cipher, -1*shift)
#end



#Arrays aren't picky about data types, so we can have any data types we want in our arrays
x=[0, "string", [1,2,3]]
x.last
x.last.first

x.sort #<--error
#Arrays are pretty handy, but if you are using several different data types, there is something that is a little more handy: a hash AKA associative array

pet1 = { "type" => "cat", "name" => "milo", "gender" => "male", "age" => 12 }
pet1["name"]
pet1["type"]

#we can also evaluate expressions inside of the brackets
key = "age"
pet1[key]
key = "gender"
pet1[key]

#keys can be ANYTHING
x = { 3.14159 => "a string", [1,2,3] => 13, {1=>2}=>"hash"}
x[(1..3).to_a]


pet1 = { :type => "cat", :name => "milo", :gender => "male", :age => 12 }
#symbols are weird little things that are unique to ruby - other are iterators, which we will cover shortly
#really, msot of the time, you just want to use a string to identify items in your hash, but you don't want to have to type a bunch of quotation marks, and those strings take up extra memory in your program
#symbols are special objects made solely for this purpose
pet1[:name]
#MUCH more common shorthand
pet2 = {type: "lobster", name: "rubicon", gender: "male", age: 2}

pet2.each{|key, value| puts "#{key}\t#{value}"}

########################################################


#similar to UNIX shell and pipes
"Nice Day Isn't It?".downcase.split("").uniq.sort.join #from wikipedia

#http://www.robertsosinski.com/2008/12/21/understanding-ruby-blocks-procs-and-lambdas/
#http://wki.pe/Ruby_(programming_language)#Examples
#http://www.troubleshooters.com/codecorn/ruby/symbols.htm
#http://nokogiri.org/Nokogiri/XML/Node.html
